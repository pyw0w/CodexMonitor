#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const SRC_DIR = path.join(ROOT, "src");
const ALLOWLIST_PATH = path.join(ROOT, "scripts", "i18n-hardcoded-ui-allowlist.txt");
const SHOULD_UPDATE = process.argv.includes("--update");

const SKIP_DIRS = new Set(["node_modules", ".git", "dist", "src-tauri"]);

function isIgnoredFile(relativePath) {
  if (!relativePath.startsWith("src/")) {
    return true;
  }
  if (relativePath.startsWith("src/i18n/")) {
    return true;
  }
  if (relativePath.endsWith(".test.ts") || relativePath.endsWith(".test.tsx")) {
    return true;
  }
  if (!(relativePath.endsWith(".ts") || relativePath.endsWith(".tsx"))) {
    return true;
  }
  return false;
}

function walk(dir, out = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (SKIP_DIRS.has(entry.name)) {
      continue;
    }
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walk(fullPath, out);
      continue;
    }
    const rel = path.relative(ROOT, fullPath).replaceAll(path.sep, "/");
    if (!isIgnoredFile(rel)) {
      out.push({ rel, fullPath });
    }
  }
  return out;
}

function isProbablyHardcodedTsxLine(line) {
  const attrPattern = /\b(aria-label|title|placeholder)=["'][^{"'][^"']*["']/;
  const visibleTextPattern = />\s*[A-Za-zА-Яа-я][^<{]*</;
  if (attrPattern.test(line)) {
    return true;
  }
  if (visibleTextPattern.test(line)) {
    return true;
  }
  return false;
}

function isProbablyHardcodedTsLine(line) {
  const objectMessagePattern = /\b(title|message|label)\s*:\s*"[^{"\s][^"]*"/;
  const alertPattern = /\bwindow\.alert\(/;
  return objectMessagePattern.test(line) || alertPattern.test(line);
}

function shouldIgnoreLine(line) {
  const trimmed = line.trim();
  if (!trimmed) {
    return true;
  }
  if (
    trimmed.startsWith("import ") ||
    trimmed.startsWith("export ") ||
    trimmed.startsWith("type ") ||
    trimmed.startsWith("interface ")
  ) {
    return true;
  }
  if (trimmed.includes("t(\"") || trimmed.includes("t('")) {
    return true;
  }
  if (trimmed.includes("{t(")) {
    return true;
  }
  return false;
}

function collectFindings() {
  const files = walk(SRC_DIR);
  const findings = [];
  for (const file of files) {
    const source = fs.readFileSync(file.fullPath, "utf8");
    const lines = source.split("\n");
    lines.forEach((line, index) => {
      if (shouldIgnoreLine(line)) {
        return;
      }
      const matched = file.rel.endsWith(".tsx")
        ? isProbablyHardcodedTsxLine(line)
        : isProbablyHardcodedTsLine(line);
      if (!matched) {
        return;
      }
      const snippet = line.trim().replace(/\s+/g, " ");
      findings.push(`${file.rel}:${index + 1}: ${snippet}`);
    });
  }
  return Array.from(new Set(findings)).sort();
}

function readAllowlist() {
  if (!fs.existsSync(ALLOWLIST_PATH)) {
    return [];
  }
  return fs
    .readFileSync(ALLOWLIST_PATH, "utf8")
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line && !line.startsWith("#"));
}

function writeAllowlist(findings) {
  const content = [
    "# Generated by scripts/check-i18n-hardcoded-ui.mjs --update",
    "# Do not hand-edit line numbers unless intentional.",
    ...findings,
    "",
  ].join("\n");
  fs.writeFileSync(ALLOWLIST_PATH, content);
}

const findings = collectFindings();

if (SHOULD_UPDATE) {
  writeAllowlist(findings);
  console.log(`Updated allowlist with ${findings.length} entries: ${path.relative(ROOT, ALLOWLIST_PATH)}`);
  process.exit(0);
}

const allowlist = readAllowlist();
const allowlistSet = new Set(allowlist);
const findingsSet = new Set(findings);

const newFindings = findings.filter((entry) => !allowlistSet.has(entry));
const staleAllowlistEntries = allowlist.filter((entry) => !findingsSet.has(entry));

if (newFindings.length > 0) {
  console.error("[i18n:check] Found new hardcoded UI strings not in allowlist:");
  for (const entry of newFindings) {
    console.error(`- ${entry}`);
  }
  console.error("");
  console.error("If intentional, update baseline with:");
  console.error("  node scripts/check-i18n-hardcoded-ui.mjs --update");
  process.exit(1);
}

if (staleAllowlistEntries.length > 0) {
  console.warn(
    `[i18n:check] ${staleAllowlistEntries.length} stale allowlist entries detected. ` +
      "Run --update to clean up.",
  );
}

console.log(`[i18n:check] OK (${findings.length} tracked hardcoded entries).`);
